module Main (main) where

import Control.Monad (when)

import Data.List (foldl')
import Data.Bits ((.&.), (.|.), xor, bitSize, shiftL, shiftR)
import Data.Word (Word32)

import Data.Vector.Unboxed (Vector, (!))
import qualified Data.Vector.Unboxed as Vector

import System.Environment (getArgs)

type CityPos = (Float, Float)
type TSP = (Int, Vector Float)

type BitSet = Word32

empty :: BitSet
empty = 0

singleton :: Int -> BitSet
singleton x = fromList [x]

insert :: Int -> BitSet -> BitSet
insert x set = (1 `shiftL` (bitSize set - x)) .|. set

delete :: Int -> BitSet -> BitSet
delete x set = (1 `shiftL` (bitSize set - x)) `xor` set

member :: Int -> BitSet -> Bool
member x set = ((1 `shiftL` (bitSize set - x)) .&. set) /= 0

fromList :: [Int] -> BitSet
fromList = foldl' (flip insert) empty

toList :: BitSet -> [Int]
toList set = [x | x <- [1 .. bitSize set], x `member` set]

subsets :: Int -> [Int] -> Vector BitSet
subsets 0 [] = Vector.singleton empty
subsets _ [] = Vector.empty
subsets i (x : xs) = Vector.concat [a, b]
  where a = Vector.map (x `insert`) (subsets (i - 1) xs)
        b = subsets i xs

subsets1 :: Int -> [Int] -> Vector BitSet
subsets1 0 _      = error "subsets1 size cannot be 0"
subsets1 _ []     = Vector.empty
subsets1 n (x : xs) = Vector.map (x `insert`) $ subsets (n - 1) xs

readTSP :: FilePath -> IO TSP
readTSP path = do
  contents <- fmap lines (readFile path)
  let n = read (head contents)
  let cities = map readCity (take n $ tail contents)

  when (n > bitSize (undefined :: BitSet)) $
    error "too many cities to store in bitset"

  return (n, Vector.concat (map (row cities) [0 .. n - 1]))

  where readCity :: String -> CityPos
        readCity s = (read x, read y)
          where [x, y] = words s

        row :: [CityPos] -> Int -> Vector Float
        row cs i = Vector.fromList [euclid from to | to <- cs]
          where from = cs !! i

        euclid :: CityPos -> CityPos -> Float
        euclid (x1, y1) (x2, y2) = sqrt $ a * a + b * b
          where a = x2 - x1
                b = y2 - y1

-- subsets vector generated by subsets* functions is sorted in descending order
subsetIndex :: BitSet -> Vector BitSet -> Int
subsetIndex x sets = go 0 (n - 1)
  where n = Vector.length sets

        go l r | l > r     = error $ "subsetIndex: missing element " ++ show (toList x)
               | x == y    = m
               | x > y     = go l (m - 1)
               | otherwise = go (m + 1) r
          where m = l + (r - l) `shiftR` 1
                y = Vector.unsafeIndex sets m

type IterState = (Vector BitSet, Vector Float)

solveTSP :: TSP -> Float
solveTSP (n, tsp) = minimum [d + c | j <- [2..n],
                                     let d = find (cities, j) final,
                                     let c = distance (j, 1)]
  where inf = 10 * Vector.sum tsp

        distance :: (Int, Int) -> Float
        distance (x, y) = tsp ! ix
          where ix = (x - 1) * n + y - 1

        cities :: BitSet
        cities = fromList [1..n]

        initial :: IterState
        initial = (Vector.singleton (singleton 1),
                   Vector.fromList [ d | j <- [1..n],
                                         let d | j == 1 = 0
                                               | otherwise = inf ])
        final :: IterState
        final = foldl' (flip ($)) initial (map iter [2..n])

        iter :: Int -> IterState -> IterState
        iter m a = (subs, ds)
          where subs = subsets1 m [1..n]
                ds = Vector.concatMap genDs subs

                genDs s = Vector.fromList [ d j | j <- [1..n] ]
                  where d j | j /= 1 && j `member` s =
                          minimum [ d' + c | k <- toList s,
                                             k /= j,
                                             let d' = find (s', k) a,
                                             let c = distance (k, j) ]
                            | otherwise = inf
                          where s' = j `delete` s

        find :: (BitSet, Int) -> IterState -> Float
        find (s, k) (as, ad) = ad ! offset
          where offset = subsetIndex s as * n + k - 1

main :: IO ()
main = do
  [path] <- getArgs
  tsp <- readTSP path

  let r = floor (solveTSP tsp) :: Int
  print r
